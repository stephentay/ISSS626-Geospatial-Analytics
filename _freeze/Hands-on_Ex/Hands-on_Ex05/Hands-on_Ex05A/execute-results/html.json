{
  "hash": "b530e2a037913dcfabdd27fbde1385a5",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Ex 5A\"\nsubtitle: \"Global Measures of Spatial Autocorrelation\"\nauthor: \"Stephen Tay\"\ndate: \"23 Sep 2024\"\ndate-modified:  \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true \n---\n\n\n# 1. Overview\n\nThis exercise introduces methods for computing **Global Measures of Spatial Autocorrelation (GMSA).** GMSA provides a summary of the overall spatial patterns within a dataset, showing whether similar values cluster together or if there is a random distribution across the entire map.\n\nSpatial autocorrelation measures how one location’s data is related to nearby locations. With global measures, we look at the entire dataset as a whole, asking questions like: Are similar values (high or low) generally located near each other? Or are values spread out randomly? GMSA gives us a single statistic that answers these questions, giving insight into the spatial structure of our data.\n\nOne common example is Moran’s I, a widely used GMSA method. It provides a value that indicates whether there is clustering (positive autocorrelation), a dispersed pattern (negative autocorrelation), or no clear pattern (no autocorrelation). These global measures help us identify broad spatial trends, which we can later break down into more detailed local measures.\n\nA key R package for GMSA analysis is the `spdep` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\n```\n:::\n\n\n# 2. Importing & Transforming Data\n\nTwo datasets will be used in this hands-on exercise:\n\n-   **Hunan County Boundary Layer**: A geospatial dataset in ESRI shapefile format.\n-   **Hunan_2012.csv**: A CSV file containing selected local development indicators for Hunan in 2012.\n\n::: panel-tabset\n## Hunan shapefile\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `/Users/stephentay/stephentay/ISSS626-Geospatial-Analytics/Hands-on_Ex/Hands-on_Ex05/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\n# crs = 4549 if need to convert\n```\n:::\n\n\n## Hunan 2012 development indicators\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nglimpse(hunan2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 88\nColumns: 29\n$ County      <chr> \"Anhua\", \"Anren\", \"Anxiang\", \"Baojing\", \"Chaling\", \"Changn…\n$ City        <chr> \"Yiyang\", \"Chenzhou\", \"Changde\", \"Hunan West\", \"Zhuzhou\", …\n$ avg_wage    <dbl> 30544, 28058, 31935, 30843, 31251, 28518, 54540, 28597, 33…\n$ deposite    <dbl> 10967.0, 4598.9, 5517.2, 2250.0, 8241.4, 10860.0, 24332.0,…\n$ FAI         <dbl> 6831.7, 6386.1, 3541.0, 1005.4, 6508.4, 7920.0, 33624.0, 1…\n$ Gov_Rev     <dbl> 456.72, 220.57, 243.64, 192.59, 620.19, 769.86, 5350.00, 1…\n$ Gov_Exp     <dbl> 2703.0, 1454.7, 1779.5, 1379.1, 1947.0, 2631.6, 7885.5, 11…\n$ GDP         <dbl> 13225.0, 4941.2, 12482.0, 4087.9, 11585.0, 19886.0, 88009.…\n$ GDPPC       <dbl> 14567, 12761, 23667, 14563, 20078, 24418, 88656, 10132, 17…\n$ GIO         <dbl> 9276.90, 4189.20, 5108.90, 3623.50, 9157.70, 37392.00, 513…\n$ Loan        <dbl> 3954.90, 2555.30, 2806.90, 1253.70, 4287.40, 4242.80, 4053…\n$ NIPCR       <dbl> 3528.3, 3271.8, 7693.7, 4191.3, 3887.7, 9528.0, 17070.0, 3…\n$ Bed         <dbl> 2718, 970, 1931, 927, 1449, 3605, 3310, 582, 2170, 2179, 1…\n$ Emp         <dbl> 494.310, 290.820, 336.390, 195.170, 330.290, 548.610, 670.…\n$ EmpR        <dbl> 441.4, 255.4, 270.5, 145.6, 299.0, 415.1, 452.0, 127.6, 21…\n$ EmpRT       <dbl> 338.0, 99.4, 205.9, 116.4, 154.0, 273.7, 219.4, 94.4, 174.…\n$ Pri_Stu     <dbl> 54.175, 33.171, 19.584, 19.249, 33.906, 81.831, 59.151, 18…\n$ Sec_Stu     <dbl> 32.830, 17.505, 17.819, 11.831, 20.548, 44.485, 39.685, 7.…\n$ Household   <dbl> 290.4, 104.6, 148.1, 73.2, 148.7, 211.2, 300.3, 76.1, 139.…\n$ Household_R <dbl> 234.5, 121.9, 135.4, 69.9, 139.4, 211.7, 248.4, 59.6, 110.…\n$ NOIP        <dbl> 101, 34, 53, 18, 106, 115, 214, 17, 55, 70, 44, 84, 74, 17…\n$ Pop_R       <dbl> 670.3, 243.2, 346.0, 184.1, 301.6, 448.2, 475.1, 189.6, 31…\n$ RSCG        <dbl> 5760.60, 2386.40, 3957.90, 768.04, 4009.50, 5220.40, 22604…\n$ Pop_T       <dbl> 910.8, 388.7, 528.3, 281.3, 578.4, 816.3, 998.6, 256.7, 45…\n$ Agri        <dbl> 4942.253, 2357.764, 4524.410, 1118.561, 3793.550, 6430.782…\n$ Service     <dbl> 5414.5, 3814.1, 14100.0, 541.8, 5444.0, 13074.6, 17726.6, …\n$ Disp_Inc    <dbl> 12373, 16072, 16610, 13455, 20461, 20868, 183252, 12379, 1…\n$ RORP        <dbl> 0.7359464, 0.6256753, 0.6549309, 0.6544614, 0.5214385, 0.5…\n$ ROREmp      <dbl> 0.8929619, 0.8782065, 0.8041262, 0.7460163, 0.9052651, 0.7…\n```\n:::\n:::\n\n\n## Combining datasets\n\nThe **GDP per Capita (GDPCC)** from `hunan2012` is needed to be added into hunan's sf dataframe. The datasets are joined by **County**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012, by = \"County\") %>%\n  select(1:4, 7, 15)\nglimpse(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 88\nColumns: 7\n$ NAME_2    <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Chan…\n$ ID_3      <int> 21098, 21100, 21101, 21102, 21103, 21104, 21109, 21110, 2111…\n$ NAME_3    <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"Li…\n$ ENGTYPE_3 <chr> \"County\", \"County\", \"County City\", \"County\", \"County\", \"Coun…\n$ County    <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", \"Li…\n$ GDPPC     <dbl> 23667, 20981, 34592, 24473, 25554, 27137, 63118, 62202, 7066…\n$ geometry  <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.2288 2…\n```\n:::\n:::\n\n:::\n\n# 3. Geovisualisation & Choropleth Map\n\nA basemap and a choropleth map showing the distribution of GDP per capita are plotted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n# 4. Preparing for Global Measures of Spatial Autocorrelation\n\nBefore we can compute global spatial autocorrelation statistics, we need to perform the following steps:\n\n::: panel-tabset\n## 1. Compute contiguity spatial weights\n\nSpatial weights define the neighborhood relationships between geographical units (e.g., counties) in the study area. In the code chunk below, the `poly2nb()` function from the `spdep` package is used to compute contiguity-based weight matrices for the study area. This function creates a list of neighboring regions by identifying those that share common boundaries. The following computes the Queen contiguity weight matrix.\n\nThe summary report indicates that there are 88 area units in Hunan. The most connected unit has 11 neighboring units, while two units have only one neighbor each.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\n## 2. Compute row-standardised weights matrix\n\nNext, we need to assign weights to each neighboring polygon. In this case, we will use equal weights (style = “W”), meaning each neighbor receives a weight of 1/(no. of neighbors). These weights are then used to calculate the weighted sum of income values from neighboring counties. While this method is straightforward and intuitive, it has a limitation: polygons on the edges of the study area may have fewer neighbors, which can lead to over- or under-estimation of spatial autocorrelation. For simplicity, we’ll use the “W” option here, but it’s worth noting that more robust alternatives, such as style = “B”, are available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n:::\n\n# 5. GMSA: Moran’s I\n\nIn this section, we will perform Moran's I statistical testing.\n\n::: panel-tabset\n## 1. Moran’s I test\n\nWe conduct Moran’s I statistical test using the `moran.test()` function from the `spdep` package. From the results, Moran’s I is 0.30, which is greater than 0, indicating positive spatial autocorrelation. Since the p-value is less than .001, the result is statistically significant. This means that the observations are not randomly distributed but are spatially clustered, with similar values tending to be near each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\n\n## 2. Monte Carlo Moran’s I test\n\nThe Monte Carlo Moran’s I test is used to assess the significance of spatial autocorrelation by comparing the observed Moran’s I to a distribution of Moran’s I values generated through random permutations. It helps determine whether the observed spatial pattern is significantly different from what could be expected under randomness.\n\nA permutation test for Moran’s I statistic conducted using `moran.mc()` function from the `spdep` package, with 1,000 simulations. This Monte Carlo approach generates a distribution of Moran’s I values by randomly shuffling the spatial data and recalculating Moran’s I for each simulation. It allows us to compare the observed Moran’s I against this randomized distribution to assess its significance.\n\nFrom the results, the observed Moran’s I statistic is 0.30, which is greater than 0, indicating positive spatial autocorrelation. Since the p-value is 0.001, the result is statistically significant. This means that the observed spatial pattern is unlikely to have occurred by chance; there is spatial clustering, where similar values tend to be located near each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm = moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n## 3. Visualising Monte Carlo Moran’s I\n\nIt is good practice to examine the simulated Moran’s I test statistics in greater detail. This can be done by plotting the distribution of these values as a histogram.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.01504572\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.004371574\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(simulated_I = bperm$res)\n\n# Plot the histogram using ggplot2\nggplot(data, aes(x = simulated_I)) +\n  geom_histogram(binwidth = diff(range(bperm$res))/20, fill=\"lightblue\", color=\"black\") +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dashed\") +\n  geom_vline(xintercept = 0.30075, color = \"purple\") +\n  annotate(\"text\", x = 0.30075, y = 100,\n           label = \"Observed Moran's I\", color = \"purple\", vjust = 0.5, hjust = 1.1) +\n  labs(x = \"Simulated Moran's I\", y = \"Frequency\", title = \"Histogram of Simulated Moran's I\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n:::\n\n# 6. GMSA: Geary's C\n\nIn this section, we will perform Geary's C statistical testing.\n\n::: panel-tabset\n## 1. Geary's C test\n\nWe conduct Geary's C statistical test using the `geary.test()` function from the `spdep` package. From the results, Geary’s C is 0.69, which is less than 1. This indicates positive spatial autocorrelation, meaning that neighboring areas tend to have similar values. Since the p-value is less than 0.001, the result is statistically significant, suggesting that the observed spatial pattern is unlikely due to random chance. Therefore, the data shows spatial clustering, where similar values tend to be located near each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n:::\n:::\n\n\n## 2. Monte Carlo Geary's C test\n\nA permutation test for Geary’s C statistic was conducted using the `geary.mc()` function from the `spdep` package, with 1,000 simulations. This Monte Carlo approach creates a distribution of Geary’s C values by randomly shuffling the spatial data and recalculating Geary’s C for each simulation. This allows us to compare the observed Geary’s C against the randomized distribution to assess the significance of the spatial autocorrelation.\n\nFrom the results, the observed Geary’s C statistic is 0.69, which is less than 1, indicating positive spatial autocorrelation. Since the p-value is 0.001, the result is statistically significant, meaning the observed spatial pattern is unlikely to have occurred by chance. Therefore, the data shows spatial clustering, where similar values are more likely to be found near each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm = geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n## 3. Visualising Monte Carlo Geary's C\n\nNext, we plot a histogram to reveal the distribution of the simulated values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.004402\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.007436493\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(simulated_C = bperm$res)\n\n# Plot the histogram using ggplot2\nggplot(data, aes(x = simulated_C)) +\n  geom_histogram(binwidth = diff(range(bperm$res))/20, fill=\"lightblue\", color=\"black\") +\n  geom_vline(xintercept = 1, color = \"red\", linetype = \"dashed\") +\n  geom_vline(xintercept = 0.69072, color = \"purple\") +\n  annotate(\"text\", x = 0.69072, y = 100,\n           label = \"Observed Geary's C\", color = \"purple\", vjust = 0.5, hjust = -0.1) +\n  labs(x = \"Simulated Geary's C\", y = \"Frequency\", title = \"Histogram of Simulated Geary's C\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n:::\n\n# 7. Spatial Correlogram\n\nA **spatial correlogram** is a tool used to assess and visualize spatial autocorrelation against increasing distances (lags) between spatial observations. It plots a measure of spatial autocorrelation, such as Moran’s I or Geary’s C, against distance, allowing us to see how relationships between spatial observations change as the distance between them increases. Correlograms help identify how far spatial dependence extends and whether it weakens, strengthens, or fluctuates with distance.\n\n::: panel-tabset\n## 1. Moran’s I correlogram\n\nThe `sp.correlogram()` function from the `spdep` package is used to compute a 6-lag spatial correlogram for GDP per capita (GDPPC), with Moran’s I as the measure of global spatial autocorrelation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nPlotting the output alone may not provide a complete interpretation, as not all autocorrelation values are statistically significant. Therefore, it’s important to review the full analysis by printing the results, as shown in the code chunk below.\n\nThe results reveal that: \n\n- **Spatial Clustering at Short Distances:** There is evidence of spatial clustering of similar GDP per capita values within shorter distances (lags 1-3). Neighboring areas are likely to have similar economic performance. \n- **Diminishing Spatial Autocorrelation with Distance:** Beyond lag 3, spatial autocorrelation weakens and eventually becomes insignificant at larger distances. This suggests that the relationship between neighboring areas becomes weaker as the distance between them increases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n## 2. Geary’s C correlogram\nIn the code chunk below, the `sp.correlogram()` function from the `spdep` package is used to compute a 6-lag spatial correlogram for GDP per capita (GDPPC), using Geary’s C as the measure of global spatial autocorrelation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05A_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nThe results reveal that: \n\n- **Spatial Clustering at Short Distances:** There is evidence of spatial clustering of similar GDP per capita values within shorter distances (lags 1-2). Neighboring areas are likely to have similar economic performance. \n- **Diminishing Spatial Autocorrelation with Distance:** Beyond lag 2, spatial autocorrelation weakens and eventually becomes insignificant at larger distances. This suggests that the relationship between neighboring areas becomes weaker as the distance between them increases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n:::\n",
    "supporting": [
      "Hands-on_Ex05A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}