{
  "hash": "af14dcf311ca98d2f8fe5616e528de87",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Ex 10\"\nsubtitle: \"Modelling Geographical Accessibility\"\nauthor: \"Stephen Tay\"\ndate: \"26 Oct 2024\"\ndate-modified:  \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true \n---\n\n\nThe hands-on exercise on **Processing & Visualising Flow Data** is in [Hands-on Ex 9A](https://geospatialanalytics-stephentay.netlify.app/hands-on_ex/hands-on_ex09/hands-on_ex09a).\n\nThe hands-on exercise on **Calibrating Spatial Interaction Models** is in [Hands-on Ex 9B](https://geospatialanalytics-stephentay.netlify.app/hands-on_ex/hands-on_ex09/hands-on_ex09b).\n\n\n# 1. Overview\n**Geographical accessibility** refers to how easily people can reach activities like work, shopping, or healthcare from a given location. It involves measuring the ease or difficulty of accessing facilities based on factors such as distance, time, and travel barriers. At its core, modelling accessibility is about quantifying movement opportunities, focusing on calculating the distance, time, or cost required to travel between locations. Geographical accessibility models can help answer questions such as:\n\n- Which regions lack access to essential facilities?\n- Which areas will be impacted by public policies, such as school closures?\n\nIn this exercise, we will model accessibility using the following three methods:\n\n- **Hansen's Potential Model:** This model estimates accessibility by summing the weighted opportunities available at various locations, with weights decreasing as the travel distance or time increases. It reflects the ease with which individuals can reach services based on proximity.\n- **Kernel Density Two-step Floating Catchment Area (KD2SFCA):** KD2SFCA refines traditional floating catchment models by incorporating a kernel density function, which accounts for the gradual decay of accessibility over distance. It evaluates access by considering both service supply and population demand across multiple zones.\n- **Spatial Accessibility Measure (SAM):** SAM quantifies the relative ease or difficulty of accessing facilities, integrating both distance and capacity constraints. It provides a spatially-aware measure of accessibility, capturing variations in service availability across regions.\n\nThe following R packages are used, with the `SpatialAcc` package playing a key role in modelling geographical accessibility.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, ggstatsplot, reshape2, tidyverse)\n```\n:::\n\n\n# 2. Importing & Preparing Data\n\nWe will import and work with four datasets:\n\n- **URA’s 2014 Master Plan Subzone Boundaries**\n- **Hexagons Dataset:** 250m radius hexagons generated using `st_make_grid()` from the `sf` package\n- **Eldercare Service Locations** from data.gov.sg\n- **Distance Matrix:** CSV file with distances between hexagons and eldercare locations\n\n::: panel-tabset\n## 1. Import master plan subzone boundaries\nNote that the `mpsz` sf dataframe does not have any EPSG information, and we will need to update its EPSG code later on.\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `/Users/stephentay/stephentay/ISSS626-Geospatial-Analytics/Hands-on_Ex/Hands-on_Ex10/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n:::\n:::\n\n## 2. Import hexagons\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `hexagons' from data source \n  `/Users/stephentay/stephentay/ISSS626-Geospatial-Analytics/Hands-on_Ex/Hands-on_Ex10/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n:::\n:::\n\n## 3. Import eldercare service locations\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `ELDERCARE' from data source \n  `/Users/stephentay/stephentay/ISSS626-Geospatial-Analytics/Hands-on_Ex/Hands-on_Ex10/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n:::\n:::\n\n## 4. Projection transformation\nSince the `mpsz` sf dataframe does not have any EPSG information, we use `st_transform` to update its EPSG code.\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n:::\n:::\n\n\n## 5. Geospatial data preparation\nWe select the relevant fields from the eldercare and hexagons datasets for the subsequent analysis. Using the `mutate()` function from the `dplyr` package, we add two new fields:\n\n- Demand in the hexagons dataset\n- Capacity in the eldercare dataset\n\nBoth fields are initially assigned a constant value of 100. However, in practice, these values should represent the actual demand of each hexagon and the true capacity of each eldercare center.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n```\n:::\n\n\n## 6. Import distance matrix\nThe original dataset is in long format, and we need to convert it to wide format, with rows representing the origins and columns representing the destinations.\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nglimpse(ODMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 375,000\nColumns: 6\n$ origin_id      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ destination_id <dbl> 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18,…\n$ entry_cost     <dbl> 667.9336, 667.9336, 667.9336, 667.9336, 667.9336, 667.9…\n$ network_cost   <dbl> 19846.87, 45026.76, 17644.17, 36009.56, 31068.09, 31194…\n$ exit_cost      <dbl> 47.64874, 31.87162, 173.47882, 92.19676, 64.62840, 117.…\n$ total_cost     <dbl> 20562.45, 45726.57, 18485.58, 36769.69, 31800.65, 31979…\n```\n:::\n:::\n\n## 7. Aspatial data preparation\nTo convert the dataset from long to wide format, we use the `spread()` function. Additionally, we convert the distance metric from meters to kilometers and transform the dataset into a matrix.\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\nhead(distmat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 120\n     `1`    `2`    `3`    `4`    `5`    `6`    `8`    `9`   `10`   `11`   `12`\n   <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n1 20562. 45727. 18486. 36770. 31801. 31980. 33198. 22963. 45943. 35593. 36362.\n2 23069. 48233. 20992. 39276. 34307. 34486. 35704. 25469. 48450. 38100. 38869.\n3 23590. 48754. 21513. 39797. 34828. 35007. 36225. 25991. 48971. 38621. 39390.\n4 24069. 49233. 21992. 40276. 35307. 35486. 36705. 26470. 49450. 39100. 39869.\n5 24241. 49405. 22164. 40448. 35479. 35658. 36877. 26642. 49622. 39272. 40041.\n6 24605. 49769. 22528. 40812. 35843. 36022. 37241. 27006. 49986. 39636. 40405.\n# ℹ 109 more variables: `13` <dbl>, `14` <dbl>, `15` <dbl>, `16` <dbl>,\n#   `18` <dbl>, `19` <dbl>, `20` <dbl>, `21` <dbl>, `22` <dbl>, `23` <dbl>,\n#   `24` <dbl>, `25` <dbl>, `26` <dbl>, `27` <dbl>, `28` <dbl>, `29` <dbl>,\n#   `30` <dbl>, `31` <dbl>, `32` <dbl>, `33` <dbl>, `34` <dbl>, `35` <dbl>,\n#   `36` <dbl>, `37` <dbl>, `38` <dbl>, `39` <dbl>, `40` <dbl>, `41` <dbl>,\n#   `42` <dbl>, `43` <dbl>, `44` <dbl>, `45` <dbl>, `46` <dbl>, `47` <dbl>,\n#   `48` <dbl>, `49` <dbl>, `50` <dbl>, `52` <dbl>, `53` <dbl>, `55` <dbl>, …\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n:::\n\n# 3. Modelling Accessibility using Hansen's Method\n\n::: panel-tabset\n## 3.1 Compute Hansen's accessibility\nHansen’s accessibility is calculated using the `ac()` function from the `SpatialAcc` package. The result is then converted to a dataframe, with the default column renamed to `accHansen` and converted into a tibble dataframe.\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n\ncolnames(acc_Hansen) <- \"accHansen\"\n\nacc_Hansen <- as_tibble(acc_Hansen)\nglimpse(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 3,125\nColumns: 1\n$ accHansen <dbl> 1.648313e-14, 1.096143e-16, 3.865857e-17, 1.482856e-17, 1.05…\n```\n:::\n:::\n\n\n`acc_Hansen` dataset is then joined to the `hexagons` sf dataframe using `bind_cols()`. `hexagon_Hansen` is now a sf dataframe.\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\nglimpse(hexagon_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 3,125\nColumns: 4\n$ fid       <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n$ demand    <dbl> 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, …\n$ accHansen <dbl> 1.648313e-14, 1.096143e-16, 3.865857e-17, 1.482856e-17, 1.05…\n$ geometry  <POLYGON [m]> POLYGON ((2667.538 27506.33..., POLYGON ((2667.538 2…\n```\n:::\n:::\n\n\n\n## 3.2 Visualise Hansen's accessibility\nThe code chunk below visualizes Hansen’s accessibility to eldercare facilities in Singapore. Before plotting, extract the extent of the hexagons sf dataframe using the `st_bbox()` function from the sf package.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmapex <- st_bbox(hexagons)\n\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n## 3.3 Statistical visualisation\nNext, we will compare the distribution of Hansen’s accessibility values across URA Planning Regions. First, we add the planning region field to the `hexagon_Hansen` sf dataframe using the code chunk below. This will allow us to visualise the distribution of Hansen’s accessibility across the Planning Regions.\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = hexagon_Hansen, \n       aes(y = log(accHansen), x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat = \"summary\", \n             fun = \"mean\", \n             colour = \"red\", \n             size = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n:::\n\n# 4. Modelling Accessibility using KD2SFCA Method\n\n::: panel-tabset\n## 4.1 Compute KD2SFCA accessibility\nThe code for computing KD2SFCA accessibility is similar to that of Hansen’s accessibility, with the key difference being the use of \"KD2SFCA\" in the `family` argument.\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- as_tibble(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n## 4.2 Visualise KD2SFCA accessibility\nThe code chunk below visualizes KD2SFCA accessibility to eldercare facilities in Singapore.\n`mapex` which contains the extent of the hexagons sf dataframe is used in the `bbox` argument.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## 4.3 Statistical visualisation\nHere we compare the distribution of KD2CFA accessibility values across URA Planning Regions. We first add the planning region field to the `hexagon_KD2SFCA` sf dataframe, before visualising the distribution of KD2CFA accessibility across the Planning Regions.\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, x = REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat = \"summary\", \n             fun = \"mean\", \n             colour = \"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n:::\n\n# 5. Modelling Accessibility using Spatial Accessibility Measure (SAM) Method\n\n::: panel-tabset\n## 5.1 Compute SAM accessibility\nTo compute SAM accessibility, we use \"SAM\" in the `family` argument.\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- as_tibble(acc_SAM)\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n## 5.2 Visualise SAM accessibility\nThe plot below visualizes SAM accessibility to eldercare facilities in Singapore. Similarly, `mapex` which contains the extent of the hexagons sf dataframe is used in the `bbox` argument.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n## 5.3 Statistical visualisation\nWe compare the distribution of SAM accessibility values across URA Planning Regions by first adding the planning region field to the `hexagon_SAM` sf dataframe. Once this field is added, we visualise the distribution of SAM accessibility across the Planning Regions.\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = hexagon_SAM, \n       aes(y = log(accSAM), x = REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat = \"summary\", \n             fun = \"mean\", \n             colour = \"red\", \n             size = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n:::\n\n",
    "supporting": [
      "Hands-on_Ex10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}